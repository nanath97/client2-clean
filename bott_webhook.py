from core import bot, dp
from aiogram import types
import os
from datetime import datetime
from aiogram.dispatcher.handler import CancelHandler
import requests
from core import authorized_users
from detect_links_whitelist import lien_non_autorise
from collections import defaultdict
from datetime import datetime, timedelta
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from ban_storage import ban_list
from middlewares.payment_filter import PaymentFilterMiddleware, reset_free_quota


# Handler pour r√©cup√©rer le file_id d'une photo
@dp.message_handler(content_types=['photo'])
async def get_photo_file_id(message: types.Message):
    file_id = message.photo[-1].file_id  # on prend la meilleure r√©solution
    await message.reply(f"üì∏ File ID de cette photo :\n{file_id}")




dp.middleware.setup(PaymentFilterMiddleware(authorized_users))



# Dictionnaire temporaire pour stocker les derniers messages de chaque client
last_messages = {}
ADMIN_ID = 1386084261
authorized_admin_ids = [ADMIN_ID]

# Constantes pour le bouton VIP et la vid√©o de bienvenue (d√©faut)
VIP_URL = "https://buy.stripe.com/9B6fZgdtb2ETaAB0nb7AI0J"
WELCOME_VIDEO_FILE_ID = "BAACAgQAAxkBAAMdaPu7_1Cx636un7S_6PpJT9c4MYsAAkEdAAK1pOBTldyvnqVBHao2BA"



pending_mass_message = {}
admin_modes = {}  # Cl√© = admin_id, Valeur = "en_attente_message"

# Mapping entre ID Telegram des admins et leur email dans Airtable 19juillet 2025 debut
ADMIN_EMAILS = {
    int(os.getenv("ADMIN_TELEGRAM_ID")): os.getenv("SELLER_EMAIL"),
}
# Mapping entre ID Telegram des admins et leur email dans Airtable 19juillet 2025 fin


# Paiements valid√©s par Stripe, stock√©s temporairement
paiements_recents = defaultdict(list)  # ex : {14: [datetime1, datetime2]}


# 1.=== Variables globales ===
DEFAULT_FLOU_IMAGE_FILE_ID = "AgACAgEAAxkBAAIOgWgSLV1I3pOt7vxnpci_ba-hb9UXAAK6rjEbM2KQRDdrQA-mqmNwAQADAgADeAADNgQ" # Remplace par le vrai file_id Telegram


# Fonction de d√©tection de lien non autoris√©
ALLOWED_DOMAINS = os.getenv("ALLOWED_DOMAINS", "").split(",")

# --- CONFIGURATION AIRTABLE ---
AIRTABLE_API_KEY = os.getenv("AIRTABLE_API_KEY")
BASE_ID = os.getenv("BASE_ID")
TABLE_NAME = os.getenv("TABLE_NAME")
SELLER_EMAIL = os.getenv("SELLER_EMAIL")  # ‚úÖ ici



# ADMIN ID
ADMIN_ID = 1386084261 # 22
DIRECTEUR_ID = 7334072965  # ID personnel au ceo pour avertir des fraudeurs

# === MEDIA EN ATTENTE ===
contenus_en_attente = {}  # { user_id: {"file_id": ..., "type": ..., "caption": ...} }
paiements_en_attente_par_user = set()  # Set de user_id qui ont pay√©
# === FIN MEDIA EN ATTENTE ===

# === 221097 DEBUT

def initialize_authorized_users():
    try:
        SELLER_EMAIL = os.getenv("SELLER_EMAIL")
        url = f"https://api.airtable.com/v0/{BASE_ID}/{TABLE_NAME.replace(' ', '%20')}"
        params = {
            "filterByFormula": f"AND({{Type acces}}='VIP', {{Email}}='{SELLER_EMAIL}')"
        }
        headers = {"Authorization": f"Bearer {AIRTABLE_API_KEY}"}
        response = requests.get(url, headers=headers, params=params)
        response.raise_for_status()
        data = response.json()
        for record in data.get("records", []):
            telegram_id = record.get("fields", {}).get("ID Telegram")
            if telegram_id:
                try:
                    authorized_users.add(int(telegram_id))
                except ValueError:
                    print(f"[WARN] ID Telegram invalide : {telegram_id}")
        print(f"[INFO] {len(authorized_users)} utilisateurs VIP charg√©s depuis Airtable pour {SELLER_EMAIL}.")
    except Exception as e:
        print(f"[ERROR] Impossible de charger les VIP depuis Airtable : {e}")

# === 221097 FIN


# === Statistiques ===
@dp.message_handler(commands=["stat"])
async def handle_stat(message: types.Message):
    await bot.send_message(message.chat.id, "üì• Traitement de tes statistiques de vente en cours...")

    try:
        SELLER_EMAIL = os.getenv("SELLER_EMAIL")  # ‚úÖ Email vendeur depuis le .env
        url = f"https://api.airtable.com/v0/{BASE_ID}/{TABLE_NAME.replace(' ', '%20')}"
        headers = {
            "Authorization": f"Bearer {AIRTABLE_API_KEY}"
        }

        response = requests.get(url, headers=headers)
        data = response.json()

        ventes_totales = 0
        ventes_jour = 0
        contenus_vendus = 0
        vip_ids = set()

        today = datetime.now().date().isoformat()
        mois_courant = datetime.now().strftime("%Y-%m")

        for record in data.get("records", []):
            fields = record.get("fields", {})
            email = fields.get("Email", "")

            # ‚úÖ Filtre pour n‚Äôinclure que les ventes du vendeur courant
            if email != SELLER_EMAIL:
                continue

            user_id = fields.get("ID Telegram", "")
            type_acces = fields.get("Type acces", "").lower()
            date_str = fields.get("Date", "")
            mois = fields.get("Mois", "")
            montant = float(fields.get("Montant", 0))

            if type_acces == "vip":
                vip_ids.add(user_id)

            if mois == mois_courant:
                ventes_totales += montant

            if date_str.startswith(today):
                ventes_jour += montant
                if type_acces != "vip":
                    contenus_vendus += 1

        clients_vip = len(vip_ids)
        benefice_net = round(ventes_totales * 0.94, 2)

        message_final = (
            f"üìä Tes statistiques de vente :\n\n"
            f"üí∞ Ventes du jour : {ventes_jour}‚Ç¨\n"
            f"üí∂ Ventes totales : {ventes_totales}‚Ç¨\n"
            f"üì¶ Contenus vendus total : {contenus_vendus}\n"
            f"üåü Clients VIP : {clients_vip}\n"
            f"üìà B√©n√©fice estim√© net : {benefice_net}‚Ç¨\n\n"
            f"_Le b√©n√©fice tient compte d‚Äôune commission de 6 %._"
        )
        vip_button = InlineKeyboardMarkup().add(
            InlineKeyboardButton("üìã Voir mes VIPs", callback_data="voir_mes_vips")
        )
        await bot.send_message(message.chat.id, message_final, parse_mode="Markdown", reply_markup=vip_button)

    except Exception as e:
        print(f"Erreur dans /stat : {e}")
        await bot.send_message(message.chat.id, "‚ùå Une erreur est survenue lors de la r√©cup√©ration des statistiques.")


# DEBUT de la fonction du proprietaire ! Ne pas toucher

@dp.message_handler(commands=["nath"])
async def handle_nath_global_stats(message: types.Message):
    if message.from_user.id != int(ADMIN_ID):
        await bot.send_message(message.chat.id, "‚ùå You do not have permission to use this command.")
        return

    await bot.send_message(message.chat.id, "üïì R√©cup√©ration des statistiques globales en cours...")

    try:
        url = f"https://api.airtable.com/v0/{BASE_ID}/{TABLE_NAME.replace(' ', '%20')}"
        headers = {
            "Authorization": f"Bearer {AIRTABLE_API_KEY}"
        }

        response = requests.get(url, headers=headers)
        data = response.json()

        ventes_par_email = {}

        for record in data.get("records", []):
            fields = record.get("fields", {})
            email = fields.get("Email", "")
            montant = float(fields.get("Montant", 0))

            if not email:
                continue

            if email not in ventes_par_email:
                ventes_par_email[email] = 0
            ventes_par_email[email] += montant

        if not ventes_par_email:
            await bot.send_message(message.chat.id, "Aucune donn√©e trouv√©e dans Airtable.")
            return

        lignes = [f"üìä R√©capitulatif global :\n"]

        for email, total in ventes_par_email.items():
            benefice = round(total * 0.94, 2)
            lignes.append(f"‚Ä¢ {email} ‚Üí {total:.2f} ‚Ç¨ (b√©n√©fice : {benefice:.2f} $)")

        lignes.append("\n_Le b√©n√©fice net tient compte d‚Äôune commission de 6 %._")

        await bot.send_message(message.chat.id, "\n".join(lignes), parse_mode="Markdown")

    except Exception as e:
        print(f"Erreur dans /nath : {e}")
        await bot.send_message(message.chat.id, "‚ùå Une erreur est survenue lors du traitement des statistiques.")

# FIN de la fonction du propri√©taire 



# Liste des clients bannis par admin
@dp.message_handler(commands=['supp'])
async def bannir_client(message: types.Message):
    if not message.reply_to_message:
        await message.reply("‚ùå Utilisez cette commande en r√©ponse au message du client √† retirer.")
        return

    user_id = None
    if message.reply_to_message.forward_from:
        user_id = message.reply_to_message.forward_from.id
    else:
        user_id = pending_replies.get((message.chat.id, message.reply_to_message.message_id))

    if not user_id:
        await message.reply("‚ùå Impossible d‚Äôidentifier le client. R√©ponds bien √† un message transf√©r√© par le bot.")
        return

    admin_id = message.from_user.id

    if admin_id not in ban_list:
        ban_list[admin_id] = []

    if user_id not in ban_list[admin_id]:
        ban_list[admin_id].append(user_id)

        await message.reply("‚úÖ Le client a √©t√© retir√© avec succ√®s.")
        try:
            await bot.send_message(user_id, "‚ùå Sorry, but you have been removed from the VIP group.")
        except Exception as e:
            print(f"Erreur lors de l'envoi du message au client banni : {e}")
            await message.reply("‚ÑπÔ∏è Le client est bien banni, mais je n‚Äôai pas pu lui envoyer le message (permissions Telegram).")
    else:
        await message.reply("‚ÑπÔ∏è Ce client est d√©j√† retir√©.")


@dp.message_handler(commands=['unsupp'])
async def reintegrer_client(message: types.Message):
    if not message.reply_to_message:
        await message.reply("‚ùå Utilisez cette commande en r√©ponse au message du client √† r√©int√©grer.")
        return

    user_id = None
    if message.reply_to_message.forward_from:
        user_id = message.reply_to_message.forward_from.id
    else:
        user_id = pending_replies.get((message.chat.id, message.reply_to_message.message_id))

    if not user_id:
        await message.reply("‚ùå Impossible d‚Äôidentifier le client. R√©ponds bien √† un message transf√©r√© par le bot.")
        return

    admin_id = message.from_user.id

    if admin_id in ban_list and user_id in ban_list[admin_id]:
        ban_list[admin_id].remove(user_id)

        await message.reply("‚úÖ Le client a √©t√© r√©int√©gr√© avec succ√®s.")
        try:
            await bot.send_message(user_id, "‚úÖ You have been reinstated to the VIP group !")
        except Exception as e:
            print(f"Erreur lors de l'envoi du message au client r√©int√©gr√© : {e}")
            await message.reply("‚ÑπÔ∏è R√©int√©gr√©, mais le message n‚Äôa pas pu √™tre envoy√© (permissions Telegram).")

    else:
        await message.reply("‚ÑπÔ∏è Ce client n‚Äô√©tait pas retir√©.")

# Mise sous forme de boutons : bannissement

@dp.message_handler(lambda message: message.text == "‚ùå Bannir le client" and message.reply_to_message and message.from_user.id == ADMIN_ID)
async def bouton_bannir(message: types.Message):
    forwarded = message.reply_to_message.forward_from
    if not forwarded:
        await message.reply("‚ùå Tu dois r√©pondre √† un message transf√©r√© du client.")
        return

    user_id = forwarded.id
    ban_list.setdefault(message.from_user.id, set()).add(user_id)
    await message.reply(f"üö´ Le client a √©t√© banni avec succ√®s.")
    try:
        await bot.send_message(user_id, "‚ùå You have been removed. You can no longer contact me.")
    except Exception as e:
        print(f"Erreur d'envoi au client banni : {e}")
        await message.reply("‚ÑπÔ∏è Le client est banni, mais je n‚Äôai pas pu lui envoyer le message.")


@dp.message_handler(lambda message: message.text == "‚úÖ R√©int√©grer le client" and message.reply_to_message and message.from_user.id == ADMIN_ID)
async def bouton_reintegrer(message: types.Message):
    forwarded = message.reply_to_message.forward_from
    if not forwarded:
        await message.reply("‚ùå Tu dois r√©pondre √† un message transf√©r√© du client.")
        return

    user_id = forwarded.id
    if user_id in ban_list.get(message.from_user.id, set()):
        ban_list[message.from_user.id].remove(user_id)
        await message.reply(f"‚úÖ Le client a √©t√© r√©int√©gr√©.")
        try:
            await bot.send_message(user_id, "‚úÖ You have been reinstated, you can contact me again.")
        except Exception as e:
            print(f"Erreur d'envoi au client r√©int√©gr√© : {e}")
            await message.reply("‚ÑπÔ∏è R√©int√©gr√©, mais je n‚Äôai pas pu lui envoyer le message.")
    else:
        await message.reply("‚ÑπÔ∏è Ce client n‚Äô√©tait pas retir√©.")

# Liste des prix autoris√©s
prix_list = [1, 3, 9, 14, 19, 24, 29, 34, 39, 44, 49, 59, 69, 79, 89, 99]

# Liste blanche des liens autoris√©s
WHITELIST_LINKS = [
    "https://novapulseonline.wixsite.com/",
    "https://buy.stripe.com/",
    "https://t.me/mini_jessie_bot?start=cdan"
    "https://t.me/Maevaoffbot?start=cdan" # 22 Rajouter  le lien propre de l'admin
]

def lien_non_autorise(text):
    words = text.split()
    for word in words:
        if word.startswith("http://") or word.startswith("https://"):
            if not any(domain.strip() in word for domain in ALLOWED_DOMAINS):
                return True
    return False

@dp.message_handler(lambda message: (message.text and ("http://" in message.text or "https://" in message.text)) or (message.caption and ("http://" in message.caption or "https://" in message.caption)), content_types=types.ContentType.ANY)
async def verifier_les_liens_uniquement(message: types.Message):
    text_to_check = message.text or message.caption or ""
    if lien_non_autorise(text_to_check):
        try:
            await bot.delete_message(chat_id=message.chat.id, message_id=message.message_id)
            await bot.send_message(chat_id=message.chat.id, text="üö´ Les liens ext√©rieurs sont interdits.")
            
            # Message perso au CEO pour avertir des fraudeurs
            await bot.send_message(DIRECTEUR_ID,
                                   f"üö® Tentative de lien interdit d√©tect√©e !\n\n"
            f"üë§ User: {message.from_user.username or message.from_user.first_name}\n"
            f"üÜî ID: {message.from_user.id}\n"
            f"üîó Lien envoy√© : {text_to_check}")

            print(f"üî¥ Lien interdit supprim√© : {text_to_check}")
        except Exception as e:
            print(f"Erreur lors de la suppression du lien interdit : {e}")
        raise CancelHandler()

# Fonction pour ajouter un paiement √† Airtable 22 Changer l'adresse mail par celui de l'admin

def log_to_airtable(pseudo, user_id, type_acces, montant, contenu="Paiement Telegram", email=None,):
    if not type_acces:
        type_acces = "Paiement"
    if email is None:
        email= SELLER_EMAIL  # Par d√©faut pour √©viter erreurs

    url = f"https://api.airtable.com/v0/{BASE_ID}/{TABLE_NAME.replace(' ', '%20')}"
    headers = {
        "Authorization": f"Bearer {AIRTABLE_API_KEY}",
        "Content-Type": "application/json"
    }

    now = datetime.now()

    fields = {
        "Pseudo Telegram": pseudo or "-",
        "ID Telegram": str(user_id),
        "Type acces": str(type_acces),
        "Montant": float(montant),
        "Contenu": contenu,
        "Email": email,
        "Date": now.isoformat(),
        "Mois": now.strftime("%Y-%m")
    }

    data = {
        "fields": fields
    }

    try:
        response = requests.post(url, json=data, headers=headers)
        if response.status_code != 200:
            print(f"‚ùå Erreur Airtable : {response.text}")
        else:
            print("‚úÖ Paiement ajout√© dans Airtable avec succ√®s !")
    except Exception as e:
        print(f"Erreur lors de l'envoi √† Airtable : {e}")


# Cr√©ation du clavier

keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
keyboard.add(
    
    types.KeyboardButton("‚ú®Discuter en tant que VIP"),
    types.KeyboardButton("‚ùó Probl√®me d'achat")
)
keyboard_admin = types.ReplyKeyboardMarkup(resize_keyboard=True)
keyboard_admin.add(
    types.KeyboardButton("üìñ Commandes"),
    types.KeyboardButton("üìä Statistiques")
)
keyboard_admin.add(# TEST bouton admin
    types.KeyboardButton("‚ùå Bannir le client"),
    types.KeyboardButton("‚úÖ R√©int√©grer le client")
)
keyboard_admin.add(
    types.KeyboardButton("‚úâÔ∏è Message √† tous les VIPs")
)

keyboard.add(
    types.KeyboardButton("üîû Voir le contenu du jour... tout en jouant üé∞")
)

# =======================
# Ajouts en haut du fichier (pr√®s des imports/vars)
# =======================
import asyncio  # si pas d√©j√† import√©
import time     # ‚¨ÖÔ∏è ajout pour le cooldown 24h
from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

DICE_WAIT_SECONDS = 2.0  # laisse l‚Äôanimation üé∞ se terminer avant d‚Äôenvoyer la r√©ponse
COOLDOWN_SECONDS = 24 * 3600  # ‚¨ÖÔ∏è cooldown 24h
last_played = {}  # ‚¨ÖÔ∏è user_id -> timestamp du dernier lancement
trigger_message = {}     # user_id -> (chat_id, message_id) du message "Voir le contenu du jour"

# NOTE: tu as d√©j√†:
# - bot, dp
# - authorized_users (set)
# - ADMIN_ID (int)
# - pending_replies: Dict[(chat_id, msg_id), user_chat_id]


# =======================
# 1) Message "Voir le contenu du jour" -> propose "Lancer la roulette"
# =======================
@dp.message_handler(lambda message: message.text == "üîû Voir le contenu du jour... tout en jouant üé∞")
async def demande_contenu_jour(message: types.Message):
    user_id = message.from_user.id

    # Non-VIP -> propose d'acheter (inchang√©)
    if user_id not in authorized_users:
        bouton_vip = InlineKeyboardMarkup().add(
            InlineKeyboardButton(
                text="üî• Rejoins le VIP pour 19 ‚Ç¨",
                url="https://buy.stripe.com/9B6fZgdtb2ETaAB0nb7AI0J"
            )
        )
        await message.reply(
            "Tu veux tenter ta chance mon coeur ? üçÄ\n\n"
"üö® Mais pour jouer et essayer d'obtenir le contenu d'aujourd'hui, tu dois √™tre un VIP.\n\n"
" Mais c'est ton jour de chance : aujourd'hui, il ne co√ªte que 9 ‚Ç¨ üéÅ ! Avec 2 photos nues et 1 vid√©o tr√®s hard de ma chatte. üîû\n\n"
"C'est simple : clique sur le bouton ci-dessous üëá et tente ta chance d√®s maintenant\n\n"
"<i>üîê Paiement s√©curis√© via Stripe</i>\n"

            "https://buy.stripe.com/9B6fZgdtb2ETaAB0nb7AI0J\n",
            reply_markup=bouton_vip,
            parse_mode="HTML"
        )
        return  # stop ici si ce n'est pas un VIP

    # VIP -> m√©moriser le message d√©clencheur d‚Äôorigine (pour le forward r√©pondable c√¥t√© admin)
    trigger_message[user_id] = (message.chat.id, message.message_id)

    # Au lieu d'envoyer direct, on propose la roulette
    bouton_roulette = InlineKeyboardMarkup().add(
        InlineKeyboardButton("‚ö°Fais tourner la roulette", callback_data="Fais tourner la roulette")
    )
    await message.reply(
        "Pr√©pare-toi √† tenter ta chance avec le contenu d'aujourd'hui... Je croise les doigts pour toi, mon ch√©rie ü§û \n\n"
        "Clique sur le bouton ci-dessous pour lancer la roulette üé∞",
        reply_markup=bouton_roulette
    )


# =======================
# 2) Callback "Lancer la roulette" -> roulette + attente + r√©ponses + forward r√©pondable
# =======================
@dp.callback_query_handler(lambda c: c.data == "Fais tourner la roulette")
async def lancer_roulette(cb: types.CallbackQuery):
    user_id = cb.from_user.id

    # ----- Cooldown 24h -----
    now = time.time()
    last = last_played.get(user_id)
    if last and (now - last) < COOLDOWN_SECONDS:
        remaining = COOLDOWN_SECONDS - (now - last)
        heures = int(remaining // 3600)
        minutes = int((remaining % 3600) // 60)
        await cb.answer(
            f"‚ö†Ô∏è Tu as d√©j√† tourn√© la roue aujourd'hui ! Reviens plus tard. {heures}h{minutes:02d}.",
            show_alert=True
        )
        return
    # Marquer le lancement maintenant (√©vite le double-clic)
    last_played[user_id] = now

    # Lancer l‚Äôanimation officielle Telegram
    dice_msg = await bot.send_dice(chat_id=user_id, emoji="üé∞")

    # Attendre la fin de l‚Äôanimation avant d'envoyer la r√©ponse (cr√©dibilit√©)
    await asyncio.sleep(DICE_WAIT_SECONDS)

    dice_value = dice_msg.dice.value

    # R√©cup√©rer le message d√©clencheur d‚Äôorigine (comme ton code d‚Äôavant)
    src_info = trigger_message.get(user_id)  # (chat_id_src, msg_id_src)
    chat_id_src, msg_id_src = (src_info if src_info else (user_id, None))

    # Message c√¥t√© client + notif admin (sans changer ton flow de r√©ponse admin)
    if dice_value >= 60:  # JACKPOT => -50% (tu envoies ensuite manuellement)
        user_msg = await bot.send_message(
            chat_id=user_id,
            text="üéâ Bravo, mon ch√©rie ! Je t'offre 50 % de r√©duction sur la vid√©o d'aujourd'hui. üî•\n"
                 "Je t'envoie ta vid√©o dans quelques instants üíï"
        )

        await bot.send_message(
            chat_id=ADMIN_ID,
            text="üì• JACKPOT (-50%) ‚Äî un VIP vient de gagner. Envoie-lui son m√©dia."
        )
    else:
        user_msg = await bot.send_message(
            chat_id=user_id,
            text="üòÖ Pas de chance cette fois-ci mon coeur‚Ä¶\n\n"
                 "Mais tu sais quoi ? Je ne vais pas te laisser les mains vides... Je offre quand m√™me 50 %  de r√©duction sur ma vid√©o du jour. üî•\n"
                 "Je te l'envoie dans quelques instantsüíï"
        )

        await bot.send_message(
            chat_id=ADMIN_ID,
            text="üì• Rat√©, mais demande de contenu du jour ( -50% offert ). Envoie-lui son m√©dia."
        )

    # üëâ Forward du message d√©clencheur d‚Äôorigine (ton ancien comportement EXACT)
    if msg_id_src is not None:
        forwarded = await bot.forward_message(
            chat_id=ADMIN_ID,
            from_chat_id=chat_id_src,
            message_id=msg_id_src
        )
        # R√©pondre √† CE message c√¥t√© admin => √ßa part directement chez l‚Äôutilisateur
        pending_replies[(forwarded.chat.id, forwarded.message_id)] = chat_id_src

    # (Optionnel) tu peux aussi forward le message que le bot vient d'envoyer au client pour contexte :
    # fwd_res = await bot.forward_message(chat_id=ADMIN_ID, from_chat_id=user_msg.chat.id, message_id=user_msg.message_id)
    # pending_replies[(fwd_res.chat.id, fwd_res.message_id)] = user_msg.chat.id

    # Fermer le spinner du bouton inline c√¥t√© client
    await cb.answer()




#fin de l'envoi du bouton du contenu du jour



from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from datetime import datetime, timedelta

@dp.message_handler(commands=["start"])
async def handle_start(message: types.Message):
    user_id = message.from_user.id
    param = (message.get_args() or "").strip()

    # === Cas A : /start=cdanXX (paiement Stripe) ===
    if param.startswith("cdan") and param[4:].isdigit():
        montant = int(param[4:])
        if montant in prix_list:
            now = datetime.now()
            paiements_valides = [
                t for t in paiements_recents.get(montant, [])
                if now - t < timedelta(minutes=3)
            ]
            if not paiements_valides:
                await bot.send_message(user_id, "‚ùå Paiement invalide ! Stripe a refus√© votre paiement en raison d'un solde insuffisant ou d'un refus g√©n√©ral. Veuillez v√©rifier vos capacit√©s de paiement.")
                await bot.send_message(ADMIN_ID, f"‚ö†Ô∏è Probl√®me ! Stripe a refus√© le paiement de ton client {message.from_user.username or message.from_user.first_name}.")
                return

            # Paiement valid√©
            paiements_recents[montant].remove(paiements_valides[0])
            authorized_users.add(user_id)
            reset_free_quota(user_id)

            if user_id in contenus_en_attente:
                contenu = contenus_en_attente[user_id]
                if contenu["type"] == types.ContentType.PHOTO:
                    await bot.send_photo(chat_id=user_id, photo=contenu["file_id"], caption=contenu.get("caption"))
                elif contenu["type"] == types.ContentType.VIDEO:
                    await bot.send_video(chat_id=user_id, video=contenu["file_id"], caption=contenu.get("caption"))
                elif contenu["type"] == types.ContentType.DOCUMENT:
                    await bot.send_document(chat_id=user_id, document=contenu["file_id"], caption=contenu.get("caption"))
                del contenus_en_attente[user_id]
            else:
                paiements_en_attente_par_user.add(user_id)

            await bot.send_message(
                user_id,
                f"‚úÖ Merci pour ton paiement de {montant}‚Ç¨ üíñ ! Ton contenu arrive dans quelques secondes...\n\n"
                f"_‚ùóÔ∏èSi tuas le moindre soucis avec ta commande, contacte-nous √† novapulse.online@gmail.com_",
                parse_mode="Markdown"
            )
            await bot.send_message(ADMIN_ID, f"üí∞ Nouveau paiement de {montant}‚Ç¨ de {message.from_user.username or message.from_user.first_name}.")
            log_to_airtable(
                pseudo=message.from_user.username or message.from_user.first_name,
                user_id=user_id,
                type_acces="Paiement",
                montant=float(montant),
                contenu="Paiement valid√© via Stripe webhook + redirection"
            )
            await bot.send_message(ADMIN_ID, "‚úÖ Paiement enregistr√© dans ton Dashboard.")
            return
        else:
            await bot.send_message(user_id, "‚ùå Le montant indiqu√© n‚Äôest pas valide.")
            return

    # === Cas B : /start=vipcdan (retour apr√®s paiement VIP) ===
    if param == "vipcdan":
        authorized_users.add(user_id)
        reset_free_quota(user_id)

        await bot.send_message(
            user_id,
            "‚ú® Bienvenue dans le VIP mon coeur üíï! Et voici ton cadeau üéÅ:"
        )

        # 1 vid√©o VIP
        await bot.send_video(chat_id=user_id, video="BAACAgQAAxkBAAMRaPu69Ia8qzfc56zKYEknX_qsfYwAAjcdAAK1pOBTBgJy5g19kV82BA")
        await bot.send_video(chat_id=user_id, video="BAACAgQAAxkBAAMTaPu7FjIwSdgbw1PAv3fRNz6MyBQAAjkdAAK1pOBTfPMdv6f1yHI2BA")
        await bot.send_video(chat_id=user_id, video="BAACAgQAAxkBAAMVaPu7TSp6N89h-pBfX_W9vAnLi3MAAjsdAAK1pOBT9JZevezh_Y42BA")
        await bot.send_video(chat_id=user_id, video="BAACAgQAAxkBAAMXaPu7eerULiJUsHu-Tedoqx-7l_EAAjwdAAK1pOBTyi8fsCElRt02BA")
        await bot.send_video(chat_id=user_id, video="BAACAgQAAxkBAAMZaPu7uviOTDuf0JvO5mrDiXX2jJgAAj8dAAK1pOBThsdqPbup4B42BA")
        await bot.send_video(chat_id=user_id, video="BAACAgQAAxkBAAMbaPu71IpIusYr4O-gs_O_QYXvQ-wAAkAdAAK1pOBTd3t8nCwHUrE2BA")

        # Logs
        await bot.send_message(ADMIN_ID, f"üåü Nouveau VIP : {message.from_user.username or message.from_user.first_name}.")
        log_to_airtable(
            pseudo=message.from_user.username or message.from_user.first_name,
            user_id=user_id,
            type_acces="VIP",
            montant=19.0,
            contenu="Pack 6 vid√©os + acc√®s VIP"
        )
        await bot.send_message(ADMIN_ID, "‚úÖ VIP Access enregistr√© dans ton dashboard.")
        return  # on sort ici pour ne pas passer √† l‚Äôaccueil normal

    # === Cas C : /start simple (accueil normal) ===
    if user_id == ADMIN_ID:
        await bot.send_message(
            user_id,
            "üëã Bonjour admin ! Tu peux voir le listing des commandes et consulter tes statistiques !",
            reply_markup=keyboard_admin
        )
        return

    # 1) Texte d‚Äôaccueil
    await bot.send_message(
        user_id,
        "üü¢ Maeva est en ligne",
        reply_markup=keyboard
    )

    # 2) Vid√©o de pr√©sentation + bouton VIP
    vip_kb = InlineKeyboardMarkup().add(
        InlineKeyboardButton("üíé Deviens un VIP", url=VIP_URL)
    )
    await bot.send_video(
        chat_id=user_id,
        video=WELCOME_VIDEO_FILE_ID,
        reply_markup=vip_kb
    )

    # 3) Image flout√©e + offre ‚Ç¨9
    vip_offer_kb = InlineKeyboardMarkup().add(
        InlineKeyboardButton("üíé Acc√®s imm√©diat pour 19 ‚Ç¨", url=VIP_URL)
    )
    await bot.send_photo(
        chat_id=user_id,
        photo=DEFAULT_FLOU_IMAGE_FILE_ID,
        caption="üî• Offre sp√©ciale valable uniquement aujourd'hui !\n - 6 vid√©os hards o√π je mouille üí¶\n- Acc√®s VIP √† vie ‚ö°\n Pour seulement 19 ‚Ç¨ \nüëâ Cliquez ci-dessous pour y acc√©der imm√©diatement !",
        reply_markup=vip_offer_kb
    )



 # TEST
@dp.message_handler(lambda message: message.text == "‚ùó Probl√®me d'achat")
async def probleme_achat(message: types.Message):
    texte_client = (
        "‚ùó *Un probl√®me avec ton achat ?*\n\n"
        "Pas de panique ! Je traite chaque cas avec le plus grand s√©rieux. "
        "Tu peux m'√©crire √† *novapulse.online@gmail.com* avec ton nom de telegram, "
        "et je vais traiter ta demande maintenant !\n\n"
        "_Je m'en charge._"
    )
    await bot.send_message(message.chat.id, texte_client, parse_mode="Markdown")

    pseudo = message.from_user.username or message.from_user.first_name or "Inconnu"
    user_id = message.from_user.id

    # üîî Alerte pour le vendeur (admin)
    await bot.send_message(ADMIN_ID,
        f"‚ö†Ô∏è *ALERTE LITIGE CLIENT* :\n\n"
        f"Le client {pseudo} (ID: {user_id}) a cliqu√© sur *'Probl√®me achat'*.\n"
        f"Pense √† v√©rifier si tout est OK.",
        parse_mode="Markdown"
    )

    # üîî Alerte pour le directeur
    await bot.send_message(DIRECTEUR_ID,
        f"üîî *Probl√®me achat d√©tect√©*\n\n"
        f"üë§ Client : {pseudo} (ID: {user_id})\n"
        f"üë®‚Äçüíº Admin concern√© : {ADMIN_ID}",
        parse_mode="Markdown"
    )

    print(f"‚úÖ Alertes envoy√©es √† ADMIN_ID ({ADMIN_ID}) et DIRECTEUR_ID ({DIRECTEUR_ID})")

# TEST FIN


    # Envoi √† l'admin (vendeur)
    try:
        await bot.send_message(ADMIN_ID, texte_alerte_admin, parse_mode="Markdown")
    except Exception as e:
        print(f"Erreur envoi admin : {e}")

    # Envoi au directeur (toi)
    try:
        await bot.send_message(DIRECTEUR_ID, texte_alerte_directeur, parse_mode="Markdown")
    except Exception as e:
        print(f"Erreur envoi directeur : {e}")


# Message avec lien

import re

@dp.message_handler(
    lambda message: message.from_user.id == ADMIN_ID and (
        (message.text and "/env" in message.text) or 
        (message.caption and "/env" in message.caption)
    ),
    content_types=[types.ContentType.TEXT, types.ContentType.PHOTO, types.ContentType.VIDEO, types.ContentType.DOCUMENT]
)
async def envoyer_lien_stripe(message: types.Message):
    if not message.reply_to_message:
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùó Utilise la commande en r√©ponse √† un message du client.")
        return

    user_id = None
    if message.reply_to_message.forward_from:
        user_id = message.reply_to_message.forward_from.id
    else:
        user_id = pending_replies.get((message.chat.id, message.reply_to_message.message_id))

    if not user_id:
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùó Impossible d'identifier le destinataire.")
        return
# 22 Mettre les liens propres √† l'admin
    liens_paiement = {
        "1": "https://buy.stripe.com/cNiaEWbl3a7l9wx3zn7AI0r",
        "9": "https://buy.stripe.com/00wdR83SB4N12457PD7AI0H",
        "14": "https://buy.stripe.com/7sY5kC60JenB5ghee17AI0I",
        "19": "https://buy.stripe.com/9B6fZgdtb2ETaAB0nb7AI0J",
        "24": "https://buy.stripe.com/aFafZgexf2ET9wx0nb7AI0K",
        "29": "https://buy.stripe.com/00w8wO1Kt5R53895Hv7AI0",
        "34": "https://buy.stripe.com/00w00i3SBdjxfUVb1P7AI0M",
        "39": "https://buy.stripe.com/aFabJ074N0wLaAB9XL7AI0N",
        "49": "https://buy.stripe.com/9B6cN4agZenBcIJc5T7AI0O",
        "59": "https://buy.stripe.com/9B66oG0GpenBeQR4Dr7AI0P",
        "69": "https://buy.stripe.com/14A6oG0GpdjxcIJ2vj7AI0Q",
        "79": "https://buy.stripe.com/eVqeVcfBj0wL389ee17AI0R",
        "89": "https://buy.stripe.com/bJebJ09cV4N12452vj7AI0S",
        "99": "https://buy.stripe.com/00w3cu2Ox2ET4cd8TH7AI0T",

        
    }

    texte = message.caption or message.text or ""
    match = re.search(r"/env(\d+|vip)", texte.lower())
    if not match:
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùó Aucun code /envXX valide d√©tect√©.")
        return

    code = match.group(1)
    lien = liens_paiement.get(code)
    if not lien:
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùó Ce montant n'est pas reconnu dans les liens disponibles.")
        return

    nouvelle_legende = re.sub(r"/env(\d+|vip)", f"{lien}", texte)

    if not (message.photo or message.video or message.document):
        await bot.send_photo(chat_id=user_id, photo=DEFAULT_FLOU_IMAGE_FILE_ID, caption=nouvelle_legende)
        await bot.send_message(
    chat_id=user_id,
    text=f"_üîí This content at {code} ‚Ç¨ is locked. Click on the link above to unlock it._",
    parse_mode="Markdown"
)


        return

    if message.content_type == types.ContentType.PHOTO:
        await bot.send_photo(chat_id=user_id, photo=message.photo[-1].file_id, caption=nouvelle_legende)
    elif message.content_type == types.ContentType.VIDEO:
        await bot.send_video(chat_id=user_id, video=message.video.file_id, caption=nouvelle_legende)
    elif message.content_type == types.ContentType.DOCUMENT:
        await bot.send_document(chat_id=user_id, document=message.document.file_id, caption=nouvelle_legende)
    else:
        await bot.send_message(chat_id=user_id, text=nouvelle_legende, disable_web_page_preview=True)

# Stocker le m√©dia personnalis√© en r√©ponse avec /dev ===
@dp.message_handler(lambda m: m.from_user.id == ADMIN_ID and (
    (m.caption and "/dev" in m.caption.lower()) or 
    (m.text and "/dev" in m.text.lower())
), content_types=types.ContentType.ANY)
async def stocker_media_par_user(message: types.Message):
    if not message.reply_to_message:
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùó Utilise cette commande en r√©ponse √† un message client.")
        return

    user_id = None
    if message.reply_to_message.forward_from:
        user_id = message.reply_to_message.forward_from.id
    else:
        user_id = pending_replies.get((message.chat.id, message.reply_to_message.message_id))

    if not user_id:
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùó Impossible d'identifier le destinataire.")
        return

    if not (message.photo or message.video or message.document):
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùó Aucun m√©dia d√©tect√©.")
        return

    contenus_en_attente[user_id] = {
        "file_id": message.photo[-1].file_id if message.photo else message.video.file_id if message.video else message.document.file_id,
        "type": message.content_type,
        "caption": (message.caption or message.text or "").replace("/dev", "").strip()
    }

    await bot.send_message(chat_id=ADMIN_ID, text=f"‚úÖ Contenu pr√™t pour l'utilisateur {user_id}.")

    # Si le client avait d√©j√† pay√© ‚Üí on lui envoie tout de suite
    if user_id in paiements_en_attente_par_user:
        contenu = contenus_en_attente[user_id]
        if contenu["type"] == types.ContentType.PHOTO:
            await bot.send_photo(chat_id=user_id, photo=contenu["file_id"], caption=contenu["caption"])
        elif contenu["type"] == types.ContentType.VIDEO:
            await bot.send_video(chat_id=user_id, video=contenu["file_id"], caption=contenu["caption"])
        elif contenu["type"] == types.ContentType.DOCUMENT:
            await bot.send_document(chat_id=user_id, document=contenu["file_id"], caption=contenu["caption"])
        paiements_en_attente_par_user.remove(user_id)
        del contenus_en_attente[user_id]   

# TEST VF debut
@dp.message_handler(lambda message: message.text == "üìñ Commandes" and message.from_user.id == ADMIN_ID)
async def show_commandes_admin(message: types.Message):
    commandes = (
        "üìñ *Liste des commandes disponibles :*\n\n"
        "üì¶ */dev* ‚Äì Stocker un contenu\n"
        "_√Ä utiliser en r√©ponse √† un message client. Joins un m√©dia (photo/vid√©o) avec la commande dans la l√©gende.Il sera plac√© en attente et se d√©bloquera au moment o√π ton client aura pay√©._\n\n"
        "üîí */envxx* ‚Äì Envoyer un contenu payant ‚Ç¨\n"
        "_Tape cette commande avec le bon montant (ex. /env14) pour envoyer un contenu flout√© avec lien de paiement de 14 ‚Ç¨. Ton client recevra directement une image flout√©e avec le lien de paiement._\n\n"
        "‚ö†Ô∏è ** ‚Äì N'oublies pas de s√©lectionner le message du client √† qui tu veux r√©pondre\n"

        "‚ö†Ô∏è ** ‚Äì Voici la liste des prix : 9, 14, 19, 24, 29, 34, 39, 44, 49, 59, 69, 79, 89, 99\n"

        "üì¨ *Besoin d‚Äôaide ?* √âcris-moi par mail : novapulse.online@gmail.com"
    )
    await message.reply(commandes, parse_mode="Markdown")

@dp.message_handler(lambda message: message.text == "üìä Statistiques" and message.from_user.id == ADMIN_ID)
async def show_stats_direct(message: types.Message):
    await handle_stat(message)

# test du r√©sume du dernier message recu 


import asyncio
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

annotations = {}   # {user_id: "texte note"}
assignations = {}  # {user_id: "nom admin en charge"}

@dp.message_handler(lambda message: message.chat.id not in authorized_admin_ids)
async def handle_admin_message(message: types.Message):
    user_id = message.from_user.id

    def escape_html(text):
        if not text:
            return "[Message vide]"
        return (
            text.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
        )

    new_msg = escape_html(message.text)
    old_msg = escape_html(last_messages.get(user_id, "Aucun message"))
    note_admin = annotations.get(user_id, "Aucune note")
    admin_en_charge = assignations.get(user_id, "Aucun")

    last_messages[user_id] = message.text or "[Message vide]"

    await bot.forward_message(ADMIN_ID, user_id, message.message_id)

    # Boutons Annoter et Prendre en charge
    keyboard = InlineKeyboardMarkup()
    keyboard.add(
        InlineKeyboardButton("‚úÖ Prendre en charge", callback_data=f"prendre_{user_id}"),
        InlineKeyboardButton("üìù Annoter", callback_data=f"annoter_{user_id}")
    )

    response = (
        "‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üß† R√âSUM√â RAPIDE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        f"üìå Ancien : {old_msg}\n"
        f"‚û°Ô∏è Nouveau : {new_msg}\n"
        f"üë§ Admin en charge : {admin_en_charge}\n"
        f"üìí Notes :\n{note_admin}\n"
        "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        "<i>Ce message sera supprim√© automatiquement dans moins de 10 secondes.</i>"
    )

    sent_msg = await bot.send_message(ADMIN_ID, response, parse_mode="HTML", reply_markup=keyboard)

    await asyncio.sleep(10)
    try:
        await bot.delete_message(chat_id=ADMIN_ID, message_id=sent_msg.message_id)
    except Exception as e:
        print(f"‚ùå Erreur suppression message : {e}")


# Handler bouton Prendre en charge
@dp.callback_query_handler(lambda c: c.data.startswith("prendre_"))
async def prendre_en_charge(call: types.CallbackQuery):
    user_id = int(call.data.split("_")[1])
    nom_admin = call.from_user.first_name or f"Admin {call.from_user.id}"
    
    assignations[user_id] = nom_admin
    await call.message.answer(f"‚úÖ {nom_admin} est maintenant en charge du client {user_id}.")

    # Supprimer confirmation apr√®s 10s
    await asyncio.sleep(10)
    try:
        await bot.delete_message(chat_id=ADMIN_ID, message_id=call.message.message_id + 1)
    except:
        pass


# Handler bouton Annoter
@dp.callback_query_handler(lambda c: c.data.startswith("annoter_"))
async def annoter_client(call: types.CallbackQuery):
    user_id = int(call.data.split("_")[1])
    await call.message.answer(f"‚úçÔ∏è √âcris la note pour ce client (ID: {user_id}).")
    
    admin_modes["annoter"] = user_id


# Handler pour r√©ception de la note
@dp.message_handler(lambda message: ADMIN_ID == message.from_user.id and admin_modes.get("annoter"))
async def enregistrer_annotation(message: types.Message):
    user_id_cible = admin_modes.pop("annoter")
    
    ancienne_note = annotations.get(user_id_cible, "")
    nouvelle_note = message.text.strip()
    
    nouvelle_ligne = f"- {nouvelle_note}"

    if ancienne_note != "Aucune note" and ancienne_note:
        annotations[user_id_cible] = ancienne_note + "\n" + nouvelle_ligne
    else:
        annotations[user_id_cible] = nouvelle_ligne

    confirmation_msg = await message.answer(
        f"‚úÖ Note ajout√©e pour le client {user_id_cible}.\nüìí Notes actuelles :\n{annotations[user_id_cible]}"
    )

    await asyncio.sleep(10)
    try:
        await bot.delete_message(chat_id=ADMIN_ID, message_id=confirmation_msg.message_id)
    except Exception as e:
        print(f"‚ùå Erreur suppression confirmation : {e}")





# fin du resume du dernier message recu 

# ======================== IMPORTS & VARIABLES ========================

# ========== IMPORTS ESSENTIELS ==========
from aiogram import types
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

# ========== HANDLER CLIENT : transfert vers admin ==========

from ban_storage import ban_list  # √† ajouter tout en haut si pas d√©j√† fait

@dp.message_handler(lambda message: message.from_user.id != ADMIN_ID, content_types=types.ContentType.ANY)
async def relay_from_client(message: types.Message):
    user_id = message.from_user.id

    # üîí V√©rifier si le client est banni par un admin
    for admin_id, clients_bannis in ban_list.items():
        if user_id in clients_bannis:
            try:
                await message.delete()
            except:
                pass
            try:
                await bot.send_message(user_id, "üö´ You have been banned. You can no longer send messages.")
            except:
                pass
            return  # ‚õî STOP : on n'envoie rien √† l'admin

    # ‚úÖ Si pas banni ‚Üí transfert normal
    try:
        sent_msg = await bot.forward_message(chat_id=ADMIN_ID, from_chat_id=message.chat.id, message_id=message.message_id)
        pending_replies[(sent_msg.chat.id, sent_msg.message_id)] = message.chat.id
        print(f"‚úÖ Message re√ßu de {message.chat.id} et transf√©r√© √† l'admin")
    except Exception as e:
        print(f"‚ùå Erreur transfert message client : {e}")



# ========== HANDLER ADMIN : r√©ponses priv√©es + messages group√©s ==========

@dp.message_handler(lambda message: message.from_user.id == ADMIN_ID, content_types=types.ContentType.ANY)
async def handle_admin_message(message: types.Message):
    mode = admin_modes.get(ADMIN_ID)

    # ‚úÖ Si l'admin clique sur "Message √† tous les VIPs"
    if message.text == "‚úâÔ∏è Message √† tous les VIPs":
        admin_modes[ADMIN_ID] = "en_attente_message"
        await bot.send_message(chat_id=ADMIN_ID, text="‚úçÔ∏è Quel message veux-tu envoyer √† tous les VIPs ?")
        return

    # ‚úÖ Si l'admin est en mode group√©, on traite le contenu du message
    if mode == "en_attente_message":
        admin_modes[ADMIN_ID] = None
        await traiter_message_group√©(message)
        return

    # ‚úÖ Sinon, on attend un reply pour une r√©ponse priv√©e
    if not message.reply_to_message:
        print("‚ùå Pas de reply d√©tect√© (et pas en mode group√©)")
        return

    # üîç Identification du destinataire
    user_id = None
    if message.reply_to_message.forward_from:
        user_id = message.reply_to_message.forward_from.id
    else:
        user_id = pending_replies.get((message.chat.id, message.reply_to_message.message_id))

    if not user_id:
        await bot.send_message(chat_id=ADMIN_ID, text="‚ùóImpossible d'identifier le destinataire.")
        return

    # ‚úÖ Envoi de la r√©ponse
    try:
        if message.text:
            await bot.send_message(chat_id=user_id, text=message.text)
        elif message.photo:
            await bot.send_photo(chat_id=user_id, photo=message.photo[-1].file_id, caption=message.caption or "")
        elif message.video:
            await bot.send_video(chat_id=user_id, video=message.video.file_id, caption=message.caption or "")
        elif message.document:
            await bot.send_document(chat_id=user_id, document=message.document.file_id, caption=message.caption or "")
        elif message.voice:
            await bot.send_voice(chat_id=user_id, voice=message.voice.file_id)
        elif message.audio:
            await bot.send_audio(chat_id=user_id, audio=message.audio.file_id, caption=message.caption or "")
        else:
            await bot.send_message(chat_id=ADMIN_ID, text="üìÇ Type de message non support√©.")
    except Exception as e:
        await bot.send_message(chat_id=ADMIN_ID, text=f"‚ùóErreur admin -> client : {e}")

# ========== TRAITEMENT MESSAGE GROUP√â VIPs ==========

async def traiter_message_group√©(message: types.Message):
    if message.text:
        pending_mass_message[ADMIN_ID] = {"type": "text", "content": message.text}
        preview = message.text
    elif message.photo:
        pending_mass_message[ADMIN_ID] = {"type": "photo", "content": message.photo[-1].file_id, "caption": message.caption or ""}
        preview = f"[Photo] {message.caption or ''}"
    elif message.video:
        pending_mass_message[ADMIN_ID] = {"type": "video", "content": message.video.file_id, "caption": message.caption or ""}
        preview = f"[Vid√©o] {message.caption or ''}"
    elif message.audio:
        pending_mass_message[ADMIN_ID] = {"type": "audio", "content": message.audio.file_id, "caption": message.caption or ""}
        preview = f"[Audio] {message.caption or ''}"
    elif message.voice:
        pending_mass_message[ADMIN_ID] = {"type": "voice", "content": message.voice.file_id}
        preview = "[Note vocale]"
    else:
        await message.reply("‚ùå Message non support√©.")
        return

    confirmation = InlineKeyboardMarkup(row_width=2)
    confirmation.add(
        InlineKeyboardButton("‚úÖ Confirmer l‚Äôenvoi", callback_data="confirmer_envoi_group√©"),
        InlineKeyboardButton("‚ùå Annuler l‚Äôenvoi", callback_data="annuler_envoi_group√©")
    )

    await message.reply(f"Pr√©visualisation :\n\n{preview}", reply_markup=confirmation)

# ========== CALLBACKS ENVOI / ANNULATION GROUP√â ==========

@dp.callback_query_handler(lambda call: call.data == "confirmer_envoi_group√©")
async def confirmer_envoi_group√©(call: types.CallbackQuery):
    await call.answer()
    message_data = pending_mass_message.get(ADMIN_ID)
    if not message_data:
        await call.message.edit_text("‚ùå Aucun message en attente √† envoyer.")
        return

    await call.message.edit_text("‚è≥ Envoi du message √† tous les VIPs...")
    envoyes = 0
    erreurs = 0

    for vip_id in authorized_users:
        try:
            if message_data["type"] == "text":
                await bot.send_message(chat_id=int(vip_id), text=message_data["content"])
            elif message_data["type"] == "photo":
                await bot.send_photo(chat_id=int(vip_id), photo=message_data["content"], caption=message_data.get("caption", ""))
            elif message_data["type"] == "video":
                await bot.send_video(chat_id=int(vip_id), video=message_data["content"], caption=message_data.get("caption", ""))
            elif message_data["type"] == "audio":
                await bot.send_audio(chat_id=int(vip_id), audio=message_data["content"], caption=message_data.get("caption", ""))
            elif message_data["type"] == "voice":
                await bot.send_voice(chat_id=int(vip_id), voice=message_data["content"])
            envoyes += 1
        except Exception as e:
            print(f"‚ùå Erreur envoi √† {vip_id} : {e}")
            erreurs += 1

    await bot.send_message(chat_id=ADMIN_ID, text=f"‚úÖ Envoy√© √† {envoyes} VIP(s).\n‚ö†Ô∏è √âchecs : {erreurs}")
    pending_mass_message.pop(ADMIN_ID, None)

@dp.callback_query_handler(lambda call: call.data == "annuler_envoi_group√©")
async def annuler_envoi_group√©(call: types.CallbackQuery):
    await call.answer("‚ùå Envoi annul√©.")
    pending_mass_message.pop(ADMIN_ID, None)
    await call.message.edit_text("‚ùå Envoi annul√©.")

#debut du 19 juillet 2025 mettre le tableau de vips
@dp.callback_query_handler(lambda c: c.data == "voir_mes_vips")
async def voir_mes_vips(callback_query: types.CallbackQuery):
    telegram_id = callback_query.from_user.id
    email = ADMIN_EMAILS.get(telegram_id)

    if not email:
        await bot.send_message(telegram_id, "‚ùå Ton e-mail admin n‚Äôest pas reconnu.")
        return

    await callback_query.answer("Chargement de tes VIPs...")

    headers = {
        "Authorization": f"Bearer {os.getenv('AIRTABLE_API_KEY')}"
    }

    url = "https://api.airtable.com/v0/appdA5tvdjXiktFzq/tblwdps52XKMk43xo"
    params = {
        "filterByFormula": f"{{Email}} = '{email}'"
    }

    response = requests.get(url, headers=headers, params=params)
    if response.status_code != 200:
        await bot.send_message(telegram_id, f"‚ùå Erreur Airtable : {response.status_code}\n\n{response.text}")
        return

    records = response.json().get("records", [])
    if not records:
        await bot.send_message(telegram_id, "üì≠ Aucun enregistrement trouv√© pour toi.")
        return

    # √âtape 1 : rep√©rer les pseudos ayant AU MOINS une ligne Type acces = VIP
    pseudos_vip = set()
    for r in records:
        f = r.get("fields", {})
        pseudo = f.get("Pseudo Telegram", "").strip()
        type_acces = f.get("Type acces", "").strip().lower()
        if pseudo and type_acces == "vip":
            pseudos_vip.add(pseudo)

    # √âtape 2 : additionner TOUS les montants (Paiement + VIP) de ces pseudos uniquement
    montants_par_pseudo = {}
    for r in records:
        f = r.get("fields", {})
        pseudo = f.get("Pseudo Telegram", "").strip()
        montant = f.get("Montant")

        if not pseudo or pseudo not in pseudos_vip:
            continue

        try:
            montant_float = float(montant)
        except:
            montant_float = 0.0

        if pseudo not in montants_par_pseudo:
            montants_par_pseudo[pseudo] = 0.0

        montants_par_pseudo[pseudo] += montant_float

    try:
        # Construction du message final avec tri et top 3
        message = "üìã Voici tes clients VIP (avec tous leurs paiements) :\n\n"
        sorted_vips = sorted(montants_par_pseudo.items(), key=lambda x: x[1], reverse=True)

        for pseudo, total in sorted_vips:
            message += f"üë§ @{pseudo} ‚Äî {round(total)} ‚Ç¨\n"

        # üèÜ Top 3
        top3 = sorted_vips[:3]
        if top3:
            message += "\nüèÜ *Top 3 clients :*\n"
            for i, (pseudo, total) in enumerate(top3):
                place = ["ü•á", "ü•à", "ü•â"]
                emoji = place[i] if i < len(place) else f"#{i+1}"
                message += f"{emoji} @{pseudo} ‚Äî {round(total)} ‚Ç¨\n"

        await bot.send_message(telegram_id, message)

    except Exception as e:
        import traceback
        error_text = traceback.format_exc()
        print("‚ùå ERREUR DANS VIPS + TOP 3 :\n", error_text)
        await bot.send_message(telegram_id, "‚ùå Une erreur est survenue lors de l'affichage des VIPs.")

#fin du 19 juillet 2025 mettre le tableau de vips








